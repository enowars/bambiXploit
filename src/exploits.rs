use regex::bytes::Regex;
use std::io::Read;
use std::{
    io,
    net::TcpStream,
    process::{Command, Stdio},
    sync::{mpsc, Arc},
    thread::{sleep, spawn},
    time::{Duration, Instant},
};

use crate::{config::Config, stats::BambiStats, submit};

/// Start the exploit script for every addresses in the config.
pub fn run(command: Arc<Vec<String>>, config: Arc<Config>, stats: Arc<BambiStats>) {
    let re = Arc::new(Regex::new(&config.flag_re).unwrap());
    let time_diff = config.interval / config.addresses.len();
    let (sender, receiver) = mpsc::channel();
    let config_clone = config.clone();
    let gather_thread = spawn(move || submit::submit_thread(receiver, config_clone, stats));
    for address in &config.addresses {
        let address_clone = address.clone();
        let config_clone = config.clone();
        let command_clone = command.clone();
        let re_clone = re.clone();
        let sender_clone = sender.clone();
        spawn(move || {
            attack_thread(
                address_clone,
                command_clone,
                re_clone,
                sender_clone,
                config_clone,
            )
        });
        sleep(Duration::from_secs(time_diff as _));
    }
    gather_thread.join().unwrap();
}

/// Start the exploit script for a given address.
fn attack_thread(
    address: String,
    command: Arc<Vec<String>>,
    re: Arc<Regex>,
    sender: mpsc::Sender<Vec<u8>>,
    config: Arc<Config>,
) {
    loop {
        // TODO move sleep here, calculate appropriate diff
        let _ = start_team_exploit(&address, &command, &re, &sender, &config);
    }
}

fn start_team_exploit(
    address: &str,
    command: &[String],
    re: &Regex,
    sender: &mpsc::Sender<Vec<u8>>,
    config: &Config,
) -> io::Result<()> {
    //println!("start_team_exploit {:?}", &command);
    let start_time = Instant::now();
    let mut command = command.to_owned();
    command.push(address.to_owned());
    let mut child = Command::new(&command[0])
        .args(&command[1..])
        .stdout(Stdio::piped())
        .spawn()?;

    // Wait for child. Post-natal abortion if required.
    loop {
        sleep(Duration::from_secs(1));

        // Is child dead?
        match child.try_wait() {
            // Yes
            Ok(Some(_exit_code)) => break,
            // No
            Ok(None) => {}
            // Maybe -- Let's kill it again just to make sure
            Err(e) => {
                let _ = child.kill();
                return Err(e);
            } // WTF is going on
        }

        // Ensure child is dead if it takes too long
        if Duration::from_secs(config.interval as _) < Instant::now() - start_time {
            let _ = child.kill();
            break;
        }
    }

    // Harvest organs ääh stdout
    let mut output = child.stdout.unwrap();
    let mut buf = vec![];
    output.read_to_end(&mut buf)?;

    for flag_match in re.find_iter(&buf) {
        // Send only fails if the other end is already closed
        sender.send(Vec::from(flag_match.as_bytes())).unwrap();
    }

    Ok(())
}
